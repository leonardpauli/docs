# java-oop-notes
' LeonardPauli/chess
	Created by Leonard Pauli, 14 sept 2018
	based on https://docs.oracle.com/javase/tutorial/java/IandI/interfaceDef.html

// 


interface:
	example:
		public interface GroupedInterface extends Interface1, Interface2, Interface3 {
			int A = 5;
			
			void doSomething(int i, double x);
			int doSomethingElse(String s);
			
			default boolean didItWork(int i, double x, String s) { return ...; }

			static int formatA(int a) { return ... };
			default int getSome(int a) { return formatA(a); }
		}
		public interface Relatable {
			int isLargerThan(Relatable other); // interface as type
		}
	"public" is Boolean: interface usable by class defined in any package
		else: only accessible to class defined in the same package (as the interface)
		// for public, any changes will be breaking for classes using it (except for default method + constant additions)
		// 	consider specifying all from start or creating new interface extending previous one
	"extends" is many Interface or Empty: extend other interfaces
		// class can subclass/extend one other class
	"body":
		- methods // implicitly public
			- abstract // followed by semicolon, no braces (ie, no implementation)
			- default // defined with the "default modifier" (?)
				// has default implementation defined in interface, optional to override in implementing class
			- static // defined with the "static" keyword
				// accessed from the interface
		- fields; constant declarations // implicitly: public, static, and final // ie. cannot be private

	usage.class:
		public class MyClass implements GroupedInterface {			
			public void doSomething(int i, double x) { ... } // required to add "public"
			public int doSomethingElse(String s) { return ...; } // required to implement all
			// didItWork not required to be implemented, because the interface defines a default variant
		}
	usage.casting.down: // if Object implements Relatable, cast object to Relatable so it can be accepted as Relatable
		public Object findLargest(Object object1, Object object2) {
   		Relatable obj1 = (Relatable)object1;
   		Relatable obj2 = (Relatable)object2;
   		return ... (obj1).isLargerThan(obj2) ...;
		}

casting.up:
	if (obj instanceof MountainBike) {
		MountainBike myBike = (MountainBike)obj;
	}

class.abstract: // similar to something between a class and an interface
	example: // ... abstract class MyClass { ... }
		abstract class GraphicObject {
			static R = 7;
			int x, y;
			...
			void moveTo(int newX, int newY) { ... }
			abstract void draw();
			abstract void resize();
		}
	usage:
		class Circle extends GraphicObject {
			void draw() { ... GraphicObject.R == Circle.R ... } // ?
			void resize() { ... }
		}
	- cannot be instantiated
	- can be subclassed
	- can contain:
		- methods
			- abstract // ie. methods without implementation
				// which has to be implemented in non-abstract subclasses
			- public / protected / private with implementation
		- fields // even those that are not static or final

class:
	example:
		public class RectanglePlus implements GroupedInterface {
			public int width = 0;
			public int height = 0;
			public Point origin;

			// constructor
			public RectanglePlus() { origin = new Point(0, 0); }
			public RectanglePlus(Point p) { origin = p; } // implicitly "this.origin"

			public int getArea() { return width * height; } // method
		}
	body:
		- method: ...
		- field
			- final // prevents subclass override
	inheritance:
		- in overriding method, ability to invoke super.method...(...)
		- in overriding constructor, ability to invoke super(...)
		- subclass does not inherit the private members of its parent class
		- nested class has access to all the private members of its enclosing class // overriding above statement
		- field hiding/shadowing: if subclass has field named the same as super, super's value can be accessed like super.field...
			class Animal {age = 5;} // does it have to be public age?
			class Dog extends Animal {age=7; int[] p() {return [age, this.age, super.age]}}
			Dog dog = new Dog(); dog.p() == [7, 7, 5]

	master base-class Object:
		// see https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html
		- public boolean equals(Object obj);
		- public String toString();
		- public final Class getClass(); // not overridable
			// eg. obj.getClass().getSimpleName()
		- public void finalize() throws Throwable; // override to provide cleanup, eg. file descriptor closing
			// possibly called by GC, but close/clean yourself when possible
		// - protected Object clone() throws CloneNotSupportedException
		// - public int hashCode()
		- ...
	good practice:
		few fields, many methods using those fields
		structure:
			- Game.Board // nested class; class Game { class Board {...} }
			- import package.Game.Board // package/Game/Board.java
			- GameBoard


enum:
	example:
		enum ChessPlayer { WHITE, BLACK }
		ChessPlayer.WHITE
		ChessPlayer.WHITE.name() == "WHITE"
	example.extended:
		public enum Modes {
			mode1 ("a"),
			mode2 ("b"),
			mode3 ("c");

			private final String name;
			private Modes(String name) { this.name = name; }
			public String toString() { return name; }
		}
		Modes.mode1.toString() == "a"


exceptions:
	example:
		// based on https://www.protechtraining.com/content/java_fundamentals_tutorial-exceptions
		public class InsufficientBalanceException extends Exception {
			private final double available;
			private final double required;

			public InsufficientBalanceException(double available, double required) {
				super("Available $"+available+" but required $"+required);
				this.available = available; this.required = required;
			}

			public double getAvailable() { return available; }
			public double getRequired() { return required; }
		}
	usage:
		void doSomething() throws InsufficientBalanceException {
			if (1==2) throw new InsufficientBalanceException(1, 2);
		}
		void proxy() throws InsufficientBalanceException { doSomething(); }
		void nice() {
			try { proxy(); } catch (InsufficientBalanceException e) { ... }
		}



# primitives

arrays:
	constant size:
		int[] xs = new int[size]
		xs.length == size
		xs[0] = 5;
		xs[0] == 5;
	dynamic size:
		import java.util.List;
		import java.util.ArrayList;
		List<MyType> xs = new ArrayList<MyType>();
		MyType x = new MyType()
		xs.add(x)
		xs.get(0) == x
		xs.size() // length
		for (MyType x : xs) { ...x... }
		xs.addAll(xs2)


strings:
	StringBuilder sb = new StringBuilder("");
	sb.append("...");
	sb.toString();


# testing

- manual testing
- code reviews
- automatic testing
	types:
		- unit tests
			a -> (b, c -> d)
			(d, b): simple unit testable, no dependencies
			c: unit test includes one dependency, a little bit larger surface area
			a: many dependencies, more of an integration test

			- expected true cases
			- expected false cases
			- edge cases
			- extreme cases
		- end-to-end, e2e, test
			like an automated userflow
			to find missing unit tests
		- regression tests
			added when a bug was fixed, to ensure it won't appear again
	- fuzz tests / random tests
		guided by code coverage and static analysis + type analysis
		generate by "evolution"
			take existing tests and "breed" them / mutate them to combine new ones
		finds bugs in "dark corners"

- formal proof
	eg. for (int a, int b)=> a+b
		see descreet mathematics
		prove commutability
		prove relation between groups
			eg. add -> mul
		unit, eg 0
		etc

code coverage // ability to see what code paths has been tested
	// see https://www.jetbrains.com/help/idea/viewing-code-coverage-results.html



